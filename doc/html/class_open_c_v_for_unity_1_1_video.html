<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>OpenCV for Unity: OpenCVForUnity.Video Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">OpenCV for Unity
   &#160;<span id="projectnumber">1.2.2</span>
   </div>
   <div id="projectbrief">Enox Software</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Packages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_open_c_v_for_unity.html">OpenCVForUnity</a></li><li class="navelem"><a class="el" href="class_open_c_v_for_unity_1_1_video.html">Video</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="class_open_c_v_for_unity_1_1_video-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">OpenCVForUnity.Video Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ada39d82368b80249ece706a52ed46b87"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_open_c_v_for_unity_1_1_rotated_rect.html">RotatedRect</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_video.html#ada39d82368b80249ece706a52ed46b87">CamShift</a> (<a class="el" href="class_open_c_v_for_unity_1_1_mat.html">Mat</a> probImage, <a class="el" href="class_open_c_v_for_unity_1_1_rect.html">Rect</a> window, <a class="el" href="class_open_c_v_for_unity_1_1_term_criteria.html">TermCriteria</a> criteria)</td></tr>
<tr class="separator:ada39d82368b80249ece706a52ed46b87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdd5433ed2d0a9cd11080115804dd552"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_video.html#abdd5433ed2d0a9cd11080115804dd552">buildOpticalFlowPyramid</a> (<a class="el" href="class_open_c_v_for_unity_1_1_mat.html">Mat</a> img, List&lt; <a class="el" href="class_open_c_v_for_unity_1_1_mat.html">Mat</a> &gt; pyramid, <a class="el" href="class_open_c_v_for_unity_1_1_size.html">Size</a> winSize, int maxLevel, bool withDerivatives, int pyrBorder, int derivBorder, bool tryReuseInputImage)</td></tr>
<tr class="separator:abdd5433ed2d0a9cd11080115804dd552"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae81d0371a756a7c49e75de0ab35ed4d1"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_video.html#ae81d0371a756a7c49e75de0ab35ed4d1">buildOpticalFlowPyramid</a> (<a class="el" href="class_open_c_v_for_unity_1_1_mat.html">Mat</a> img, List&lt; <a class="el" href="class_open_c_v_for_unity_1_1_mat.html">Mat</a> &gt; pyramid, <a class="el" href="class_open_c_v_for_unity_1_1_size.html">Size</a> winSize, int maxLevel)</td></tr>
<tr class="separator:ae81d0371a756a7c49e75de0ab35ed4d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa224330bcb6927b54ce1ad5d6480603a"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_video.html#aa224330bcb6927b54ce1ad5d6480603a">calcGlobalOrientation</a> (<a class="el" href="class_open_c_v_for_unity_1_1_mat.html">Mat</a> orientation, <a class="el" href="class_open_c_v_for_unity_1_1_mat.html">Mat</a> mask, <a class="el" href="class_open_c_v_for_unity_1_1_mat.html">Mat</a> mhi, double timestamp, double duration)</td></tr>
<tr class="separator:aa224330bcb6927b54ce1ad5d6480603a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b0bd5bfbfc24901700cd79a0d26be7c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_video.html#a8b0bd5bfbfc24901700cd79a0d26be7c">calcMotionGradient</a> (<a class="el" href="class_open_c_v_for_unity_1_1_mat.html">Mat</a> mhi, <a class="el" href="class_open_c_v_for_unity_1_1_mat.html">Mat</a> mask, <a class="el" href="class_open_c_v_for_unity_1_1_mat.html">Mat</a> orientation, double delta1, double delta2, int apertureSize)</td></tr>
<tr class="separator:a8b0bd5bfbfc24901700cd79a0d26be7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa39bb6b110b60bfc20d996b25e0ba1f9"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_video.html#aa39bb6b110b60bfc20d996b25e0ba1f9">calcMotionGradient</a> (<a class="el" href="class_open_c_v_for_unity_1_1_mat.html">Mat</a> mhi, <a class="el" href="class_open_c_v_for_unity_1_1_mat.html">Mat</a> mask, <a class="el" href="class_open_c_v_for_unity_1_1_mat.html">Mat</a> orientation, double delta1, double delta2)</td></tr>
<tr class="separator:aa39bb6b110b60bfc20d996b25e0ba1f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd4c7dcabc2c7eecdfcf8aedbd59176b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_video.html#abd4c7dcabc2c7eecdfcf8aedbd59176b">calcOpticalFlowFarneback</a> (<a class="el" href="class_open_c_v_for_unity_1_1_mat.html">Mat</a> prev, <a class="el" href="class_open_c_v_for_unity_1_1_mat.html">Mat</a> next, <a class="el" href="class_open_c_v_for_unity_1_1_mat.html">Mat</a> flow, double pyr_scale, int levels, int winsize, int iterations, int poly_n, double poly_sigma, int flags)</td></tr>
<tr class="separator:abd4c7dcabc2c7eecdfcf8aedbd59176b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b7fb685e96bb061d8eb339642e30191"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_video.html#a4b7fb685e96bb061d8eb339642e30191">calcOpticalFlowPyrLK</a> (<a class="el" href="class_open_c_v_for_unity_1_1_mat.html">Mat</a> prevImg, <a class="el" href="class_open_c_v_for_unity_1_1_mat.html">Mat</a> nextImg, <a class="el" href="class_open_c_v_for_unity_1_1_mat_of_point2f.html">MatOfPoint2f</a> prevPts, <a class="el" href="class_open_c_v_for_unity_1_1_mat_of_point2f.html">MatOfPoint2f</a> nextPts, <a class="el" href="class_open_c_v_for_unity_1_1_mat_of_byte.html">MatOfByte</a> status, <a class="el" href="class_open_c_v_for_unity_1_1_mat_of_float.html">MatOfFloat</a> err, <a class="el" href="class_open_c_v_for_unity_1_1_size.html">Size</a> winSize, int maxLevel, <a class="el" href="class_open_c_v_for_unity_1_1_term_criteria.html">TermCriteria</a> criteria, int flags, double minEigThreshold)</td></tr>
<tr class="separator:a4b7fb685e96bb061d8eb339642e30191"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43da6a127b735b97001fa81ab6c98aac"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_video.html#a43da6a127b735b97001fa81ab6c98aac">calcOpticalFlowPyrLK</a> (<a class="el" href="class_open_c_v_for_unity_1_1_mat.html">Mat</a> prevImg, <a class="el" href="class_open_c_v_for_unity_1_1_mat.html">Mat</a> nextImg, <a class="el" href="class_open_c_v_for_unity_1_1_mat_of_point2f.html">MatOfPoint2f</a> prevPts, <a class="el" href="class_open_c_v_for_unity_1_1_mat_of_point2f.html">MatOfPoint2f</a> nextPts, <a class="el" href="class_open_c_v_for_unity_1_1_mat_of_byte.html">MatOfByte</a> status, <a class="el" href="class_open_c_v_for_unity_1_1_mat_of_float.html">MatOfFloat</a> err, <a class="el" href="class_open_c_v_for_unity_1_1_size.html">Size</a> winSize, int maxLevel)</td></tr>
<tr class="separator:a43da6a127b735b97001fa81ab6c98aac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3b67253e8d617cdfbfa3a11130fccd6"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_video.html#ad3b67253e8d617cdfbfa3a11130fccd6">calcOpticalFlowPyrLK</a> (<a class="el" href="class_open_c_v_for_unity_1_1_mat.html">Mat</a> prevImg, <a class="el" href="class_open_c_v_for_unity_1_1_mat.html">Mat</a> nextImg, <a class="el" href="class_open_c_v_for_unity_1_1_mat_of_point2f.html">MatOfPoint2f</a> prevPts, <a class="el" href="class_open_c_v_for_unity_1_1_mat_of_point2f.html">MatOfPoint2f</a> nextPts, <a class="el" href="class_open_c_v_for_unity_1_1_mat_of_byte.html">MatOfByte</a> status, <a class="el" href="class_open_c_v_for_unity_1_1_mat_of_float.html">MatOfFloat</a> err)</td></tr>
<tr class="separator:ad3b67253e8d617cdfbfa3a11130fccd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac33aa50f9ddb2ffdafb37bfaa5f6403d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_video.html#ac33aa50f9ddb2ffdafb37bfaa5f6403d">calcOpticalFlowSF</a> (<a class="el" href="class_open_c_v_for_unity_1_1_mat.html">Mat</a> from, <a class="el" href="class_open_c_v_for_unity_1_1_mat.html">Mat</a> to, <a class="el" href="class_open_c_v_for_unity_1_1_mat.html">Mat</a> flow, int layers, int averaging_block_size, int max_flow)</td></tr>
<tr class="separator:ac33aa50f9ddb2ffdafb37bfaa5f6403d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cbbdb473e74e22c0b173db981838e72"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_video.html#a3cbbdb473e74e22c0b173db981838e72">calcOpticalFlowSF</a> (<a class="el" href="class_open_c_v_for_unity_1_1_mat.html">Mat</a> from, <a class="el" href="class_open_c_v_for_unity_1_1_mat.html">Mat</a> to, <a class="el" href="class_open_c_v_for_unity_1_1_mat.html">Mat</a> flow, int layers, int averaging_block_size, int max_flow, double sigma_dist, double sigma_color, int postprocess_window, double sigma_dist_fix, double sigma_color_fix, double occ_thr, int upscale_averaging_radius, double upscale_sigma_dist, double upscale_sigma_color, double speed_up_thr)</td></tr>
<tr class="separator:a3cbbdb473e74e22c0b173db981838e72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2daabeecdb0a1c965b9d64cdcae4fdbd"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_open_c_v_for_unity_1_1_mat.html">Mat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_video.html#a2daabeecdb0a1c965b9d64cdcae4fdbd">estimateRigidTransform</a> (<a class="el" href="class_open_c_v_for_unity_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_mat.html">Mat</a> dst, bool fullAffine)</td></tr>
<tr class="separator:a2daabeecdb0a1c965b9d64cdcae4fdbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc1fbfaaec0372c681161761a5ea9de2"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_video.html#adc1fbfaaec0372c681161761a5ea9de2">meanShift</a> (<a class="el" href="class_open_c_v_for_unity_1_1_mat.html">Mat</a> probImage, <a class="el" href="class_open_c_v_for_unity_1_1_rect.html">Rect</a> window, <a class="el" href="class_open_c_v_for_unity_1_1_term_criteria.html">TermCriteria</a> criteria)</td></tr>
<tr class="separator:adc1fbfaaec0372c681161761a5ea9de2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c47ec68ea0a534ac593795f2d04f33e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_video.html#a5c47ec68ea0a534ac593795f2d04f33e">segmentMotion</a> (<a class="el" href="class_open_c_v_for_unity_1_1_mat.html">Mat</a> mhi, <a class="el" href="class_open_c_v_for_unity_1_1_mat.html">Mat</a> segmask, <a class="el" href="class_open_c_v_for_unity_1_1_mat_of_rect.html">MatOfRect</a> boundingRects, double timestamp, double segThresh)</td></tr>
<tr class="separator:a5c47ec68ea0a534ac593795f2d04f33e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a067f4aa0a58ad4e8514610dc102faf03"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_video.html#a067f4aa0a58ad4e8514610dc102faf03">updateMotionHistory</a> (<a class="el" href="class_open_c_v_for_unity_1_1_mat.html">Mat</a> silhouette, <a class="el" href="class_open_c_v_for_unity_1_1_mat.html">Mat</a> mhi, double timestamp, double duration)</td></tr>
<tr class="separator:a067f4aa0a58ad4e8514610dc102faf03"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a889951e2e5caf051015e8b46247ea73d"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_video.html#a889951e2e5caf051015e8b46247ea73d">OPTFLOW_USE_INITIAL_FLOW</a> = CV_LKFLOW_INITIAL_GUESSES</td></tr>
<tr class="separator:a889951e2e5caf051015e8b46247ea73d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8a128cacf80c603f4e4ec606bdb7c96"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_video.html#ab8a128cacf80c603f4e4ec606bdb7c96">OPTFLOW_LK_GET_MIN_EIGENVALS</a> = CV_LKFLOW_GET_MIN_EIGENVALS</td></tr>
<tr class="separator:ab8a128cacf80c603f4e4ec606bdb7c96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedde09a0a8a8e53ea12e220addf457e8"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_video.html#aedde09a0a8a8e53ea12e220addf457e8">OPTFLOW_FARNEBACK_GAUSSIAN</a> = 256</td></tr>
<tr class="separator:aedde09a0a8a8e53ea12e220addf457e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="abdd5433ed2d0a9cd11080115804dd552"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int OpenCVForUnity.Video.buildOpticalFlowPyramid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">List&lt; <a class="el" href="class_open_c_v_for_unity_1_1_mat.html">Mat</a> &gt;&#160;</td>
          <td class="paramname"><em>pyramid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_size.html">Size</a>&#160;</td>
          <td class="paramname"><em>winSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>withDerivatives</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pyrBorder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>derivBorder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>tryReuseInputImage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructs the image pyramid which can be passed to "calcOpticalFlowPyrLK".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">img</td><td>8-bit input image. </td></tr>
    <tr><td class="paramname">pyramid</td><td>output pyramid. </td></tr>
    <tr><td class="paramname">winSize</td><td>window size of optical flow algorithm. Must be not less than <code>winSize</code> argument of "calcOpticalFlowPyrLK". It is needed to calculate required padding for pyramid levels. </td></tr>
    <tr><td class="paramname">maxLevel</td><td>0-based maximal pyramid level number. </td></tr>
    <tr><td class="paramname">withDerivatives</td><td>set to precompute gradients for the every pyramid level. If pyramid is constructed without the gradients then "calcOpticalFlowPyrLK" will calculate them internally. </td></tr>
    <tr><td class="paramname">pyrBorder</td><td>the border mode for pyramid layers. </td></tr>
    <tr><td class="paramname">derivBorder</td><td>the border mode for gradients. </td></tr>
    <tr><td class="paramname">tryReuseInputImage</td><td>put ROI of input image into the pyramid if possible. You can pass <code>false</code> to force data copying.</td></tr>
  </table>
  </dd>
</dl>
<p>:return: number of levels in constructed pyramid. Can be less than <code>maxLevel</code>.</p>
<dl class="section see"><dt>See also</dt><dd><a href="http://docs.opencv.org/modules/video/doc/motion_analysis_and_object_tracking.html#buildopticalflowpyramid">org.opencv.video.Video.buildOpticalFlowPyramid</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae81d0371a756a7c49e75de0ab35ed4d1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int OpenCVForUnity.Video.buildOpticalFlowPyramid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">List&lt; <a class="el" href="class_open_c_v_for_unity_1_1_mat.html">Mat</a> &gt;&#160;</td>
          <td class="paramname"><em>pyramid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_size.html">Size</a>&#160;</td>
          <td class="paramname"><em>winSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxLevel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructs the image pyramid which can be passed to "calcOpticalFlowPyrLK".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">img</td><td>8-bit input image. </td></tr>
    <tr><td class="paramname">pyramid</td><td>output pyramid. </td></tr>
    <tr><td class="paramname">winSize</td><td>window size of optical flow algorithm. Must be not less than <code>winSize</code> argument of "calcOpticalFlowPyrLK". It is needed to calculate required padding for pyramid levels. </td></tr>
    <tr><td class="paramname">maxLevel</td><td>0-based maximal pyramid level number.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="http://docs.opencv.org/modules/video/doc/motion_analysis_and_object_tracking.html#buildopticalflowpyramid">org.opencv.video.Video.buildOpticalFlowPyramid</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa224330bcb6927b54ce1ad5d6480603a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double OpenCVForUnity.Video.calcGlobalOrientation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>orientation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>mhi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>timestamp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>duration</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates a global motion orientation in a selected region.</p>
<p>The function calculates an average motion direction in the selected region and returns the angle between 0 degrees and 360 degrees. The average direction is computed from the weighted orientation histogram, where a recent motion has a larger weight and the motion occurred in the past has a smaller weight, as recorded in <code>mhi</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">orientation</td><td>Motion gradient orientation image calculated by the function "calcMotionGradient". </td></tr>
    <tr><td class="paramname">mask</td><td>Mask image. It may be a conjunction of a valid gradient mask, also calculated by "calcMotionGradient", and the mask of a region whose direction needs to be calculated. </td></tr>
    <tr><td class="paramname">mhi</td><td>Motion history image calculated by "updateMotionHistory". </td></tr>
    <tr><td class="paramname">timestamp</td><td>Timestamp passed to "updateMotionHistory". </td></tr>
    <tr><td class="paramname">duration</td><td>Maximum duration of a motion track in milliseconds, passed to "updateMotionHistory".</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="http://docs.opencv.org/modules/video/doc/motion_analysis_and_object_tracking.html#calcglobalorientation">org.opencv.video.Video.calcGlobalOrientation</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a8b0bd5bfbfc24901700cd79a0d26be7c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.Video.calcMotionGradient </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>mhi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>orientation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>delta1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>delta2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>apertureSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates a gradient orientation of a motion history image.</p>
<p>The function calculates a gradient orientation at each pixel <em>(x, y)</em> as:</p>
<p><em>orientation(x,y)= arctan((dmhi/dy)/(dmhi/dx))</em></p>
<p>In fact, "fastAtan2" and "phase" are used so that the computed angle is measured in degrees and covers the full range 0..360. Also, the <code>mask</code> is filled to indicate pixels where the computed angle is valid.</p>
<p>Note:</p>
<ul>
<li>
(Python) An example on how to perform a motion template technique can be found at opencv_source_code/samples/python2/motempl.py </li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mhi</td><td>Motion history single-channel floating-point image. </td></tr>
    <tr><td class="paramname">mask</td><td>Output mask image that has the type <code>CV_8UC1</code> and the same size as <code>mhi</code>. Its non-zero elements mark pixels where the motion gradient data is correct. </td></tr>
    <tr><td class="paramname">orientation</td><td>Output motion gradient orientation image that has the same type and the same size as <code>mhi</code>. Each pixel of the image is a motion orientation, from 0 to 360 degrees. </td></tr>
    <tr><td class="paramname">delta1</td><td>Minimal (or maximal) allowed difference between <code>mhi</code> values within a pixel neighborhood. </td></tr>
    <tr><td class="paramname">delta2</td><td>Maximal (or minimal) allowed difference between <code>mhi</code> values within a pixel neighborhood. That is, the function finds the minimum (<em>m(x,y)</em>) and maximum (<em>M(x,y)</em>) <code>mhi</code> values over <em>3 x 3</em> neighborhood of each pixel and marks the motion orientation at <em>(x, y)</em> as valid only if</td></tr>
  </table>
  </dd>
</dl>
<p><em>min(delta1, delta2) &lt;= M(x,y)-m(x,y) &lt;= max(delta1, delta2).</em></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">apertureSize</td><td>Aperture size of the "Sobel" operator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="http://docs.opencv.org/modules/video/doc/motion_analysis_and_object_tracking.html#calcmotiongradient">org.opencv.video.Video.calcMotionGradient</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa39bb6b110b60bfc20d996b25e0ba1f9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.Video.calcMotionGradient </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>mhi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>orientation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>delta1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>delta2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates a gradient orientation of a motion history image.</p>
<p>The function calculates a gradient orientation at each pixel <em>(x, y)</em> as:</p>
<p><em>orientation(x,y)= arctan((dmhi/dy)/(dmhi/dx))</em></p>
<p>In fact, "fastAtan2" and "phase" are used so that the computed angle is measured in degrees and covers the full range 0..360. Also, the <code>mask</code> is filled to indicate pixels where the computed angle is valid.</p>
<p>Note:</p>
<ul>
<li>
(Python) An example on how to perform a motion template technique can be found at opencv_source_code/samples/python2/motempl.py </li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mhi</td><td>Motion history single-channel floating-point image. </td></tr>
    <tr><td class="paramname">mask</td><td>Output mask image that has the type <code>CV_8UC1</code> and the same size as <code>mhi</code>. Its non-zero elements mark pixels where the motion gradient data is correct. </td></tr>
    <tr><td class="paramname">orientation</td><td>Output motion gradient orientation image that has the same type and the same size as <code>mhi</code>. Each pixel of the image is a motion orientation, from 0 to 360 degrees. </td></tr>
    <tr><td class="paramname">delta1</td><td>Minimal (or maximal) allowed difference between <code>mhi</code> values within a pixel neighborhood. </td></tr>
    <tr><td class="paramname">delta2</td><td>Maximal (or minimal) allowed difference between <code>mhi</code> values within a pixel neighborhood. That is, the function finds the minimum (<em>m(x,y)</em>) and maximum (<em>M(x,y)</em>) <code>mhi</code> values over <em>3 x 3</em> neighborhood of each pixel and marks the motion orientation at <em>(x, y)</em> as valid only if</td></tr>
  </table>
  </dd>
</dl>
<p><em>min(delta1, delta2) &lt;= M(x,y)-m(x,y) &lt;= max(delta1, delta2).</em></p>
<dl class="section see"><dt>See also</dt><dd><a href="http://docs.opencv.org/modules/video/doc/motion_analysis_and_object_tracking.html#calcmotiongradient">org.opencv.video.Video.calcMotionGradient</a> </dd></dl>

</div>
</div>
<a class="anchor" id="abd4c7dcabc2c7eecdfcf8aedbd59176b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.Video.calcOpticalFlowFarneback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>prev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>next</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>flow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>pyr_scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>levels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>winsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iterations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>poly_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>poly_sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Computes a dense optical flow using the Gunnar Farneback's algorithm.</p>
<p>The function finds an optical flow for each <code>prev</code> pixel using the [Farneback2003] algorithm so that</p>
<p><em>prev(y,x) ~ next(y + flow(y,x)[1], x + flow(y,x)[0])</em></p>
<p>Note:</p>
<ul>
<li>
An example using the optical flow algorithm described by Gunnar Farneback can be found at opencv_source_code/samples/cpp/fback.cpp </li>
<li>
(Python) An example using the optical flow algorithm described by Gunnar Farneback can be found at opencv_source_code/samples/python2/opt_flow.py </li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prev</td><td>first 8-bit single-channel input image. </td></tr>
    <tr><td class="paramname">next</td><td>second input image of the same size and the same type as <code>prev</code>. </td></tr>
    <tr><td class="paramname">flow</td><td>computed flow image that has the same size as <code>prev</code> and type <code>CV_32FC2</code>. </td></tr>
    <tr><td class="paramname">pyr_scale</td><td>parameter, specifying the image scale (&lt;1) to build pyramids for each image; <code>pyr_scale=0.5</code> means a classical pyramid, where each next layer is twice smaller than the previous one. </td></tr>
    <tr><td class="paramname">levels</td><td>number of pyramid layers including the initial image; <code>levels=1</code> means that no extra layers are created and only the original images are used. </td></tr>
    <tr><td class="paramname">winsize</td><td>averaging window size; larger values increase the algorithm robustness to image noise and give more chances for fast motion detection, but yield more blurred motion field. </td></tr>
    <tr><td class="paramname">iterations</td><td>number of iterations the algorithm does at each pyramid level. </td></tr>
    <tr><td class="paramname">poly_n</td><td>size of the pixel neighborhood used to find polynomial expansion in each pixel; larger values mean that the image will be approximated with smoother surfaces, yielding more robust algorithm and more blurred motion field, typically <code>poly_n</code> =5 or 7. </td></tr>
    <tr><td class="paramname">poly_sigma</td><td>standard deviation of the Gaussian that is used to smooth derivatives used as a basis for the polynomial expansion; for <code>poly_n=5</code>, you can set <code>poly_sigma=1.1</code>, for <code>poly_n=7</code>, a good value would be <code>poly_sigma=1.5</code>. </td></tr>
    <tr><td class="paramname">flags</td><td>operation flags that can be a combination of the following: <ul>
<li>
OPTFLOW_USE_INITIAL_FLOW uses the input <code>flow</code> as an initial flow approximation. </li>
<li>
OPTFLOW_FARNEBACK_GAUSSIAN uses the Gaussian <em>winsizexwinsize</em> filter instead of a box filter of the same size for optical flow estimation; usually, this option gives z more accurate flow than with a box filter, at the cost of lower speed; normally, <code>winsize</code> for a Gaussian window should be set to a larger value to achieve the same level of robustness. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="http://docs.opencv.org/modules/video/doc/motion_analysis_and_object_tracking.html#calcopticalflowfarneback">org.opencv.video.Video.calcOpticalFlowFarneback</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a4b7fb685e96bb061d8eb339642e30191"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.Video.calcOpticalFlowPyrLK </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>prevImg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>nextImg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_mat_of_point2f.html">MatOfPoint2f</a>&#160;</td>
          <td class="paramname"><em>prevPts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_mat_of_point2f.html">MatOfPoint2f</a>&#160;</td>
          <td class="paramname"><em>nextPts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_mat_of_byte.html">MatOfByte</a>&#160;</td>
          <td class="paramname"><em>status</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_mat_of_float.html">MatOfFloat</a>&#160;</td>
          <td class="paramname"><em>err</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_size.html">Size</a>&#160;</td>
          <td class="paramname"><em>winSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_term_criteria.html">TermCriteria</a>&#160;</td>
          <td class="paramname"><em>criteria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>minEigThreshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates an optical flow for a sparse feature set using the iterative Lucas-Kanade method with pyramids.</p>
<p>The function implements a sparse iterative version of the Lucas-Kanade optical flow in pyramids. See [Bouguet00]. The function is parallelized with the TBB library.</p>
<p>Note:</p>
<ul>
<li>
An example using the Lucas-Kanade optical flow algorithm can be found at opencv_source_code/samples/cpp/lkdemo.cpp </li>
<li>
(Python) An example using the Lucas-Kanade optical flow algorithm can be found at opencv_source_code/samples/python2/lk_track.py </li>
<li>
(Python) An example using the Lucas-Kanade tracker for homography matching can be found at opencv_source_code/samples/python2/lk_homography.py </li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prevImg</td><td>first 8-bit input image or pyramid constructed by "buildOpticalFlowPyramid". </td></tr>
    <tr><td class="paramname">nextImg</td><td>second input image or pyramid of the same size and the same type as <code>prevImg</code>. </td></tr>
    <tr><td class="paramname">prevPts</td><td>vector of 2D points for which the flow needs to be found; point coordinates must be single-precision floating-point numbers. </td></tr>
    <tr><td class="paramname">nextPts</td><td>output vector of 2D points (with single-precision floating-point coordinates) containing the calculated new positions of input features in the second image; when <code>OPTFLOW_USE_INITIAL_FLOW</code> flag is passed, the vector must have the same size as in the input. </td></tr>
    <tr><td class="paramname">status</td><td>output status vector (of unsigned chars); each element of the vector is set to 1 if the flow for the corresponding features has been found, otherwise, it is set to 0. </td></tr>
    <tr><td class="paramname">err</td><td>output vector of errors; each element of the vector is set to an error for the corresponding feature, type of the error measure can be set in <code>flags</code> parameter; if the flow wasn't found then the error is not defined (use the <code>status</code> parameter to find such cases). </td></tr>
    <tr><td class="paramname">winSize</td><td>size of the search window at each pyramid level. </td></tr>
    <tr><td class="paramname">maxLevel</td><td>0-based maximal pyramid level number; if set to 0, pyramids are not used (single level), if set to 1, two levels are used, and so on; if pyramids are passed to input then algorithm will use as many levels as pyramids have but no more than <code>maxLevel</code>. </td></tr>
    <tr><td class="paramname">criteria</td><td>parameter, specifying the termination criteria of the iterative search algorithm (after the specified maximum number of iterations <code>criteria.maxCount</code> or when the search window moves by less than <code>criteria.epsilon</code>. </td></tr>
    <tr><td class="paramname">flags</td><td>operation flags: <ul>
<li>
OPTFLOW_USE_INITIAL_FLOW uses initial estimations, stored in <code>nextPts</code>; if the flag is not set, then <code>prevPts</code> is copied to <code>nextPts</code> and is considered the initial estimate. </li>
<li>
OPTFLOW_LK_GET_MIN_EIGENVALS use minimum eigen values as an error measure (see <code>minEigThreshold</code> description); if the flag is not set, then L1 distance between patches around the original and a moved point, divided by number of pixels in a window, is used as a error measure. </li>
</ul>
</td></tr>
    <tr><td class="paramname">minEigThreshold</td><td>the algorithm calculates the minimum eigen value of a 2x2 normal matrix of optical flow equations (this matrix is called a spatial gradient matrix in [Bouguet00]), divided by number of pixels in a window; if this value is less than <code>minEigThreshold</code>, then a corresponding feature is filtered out and its flow is not processed, so it allows to remove bad points and get a performance boost.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="http://docs.opencv.org/modules/video/doc/motion_analysis_and_object_tracking.html#calcopticalflowpyrlk">org.opencv.video.Video.calcOpticalFlowPyrLK</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a43da6a127b735b97001fa81ab6c98aac"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.Video.calcOpticalFlowPyrLK </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>prevImg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>nextImg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_mat_of_point2f.html">MatOfPoint2f</a>&#160;</td>
          <td class="paramname"><em>prevPts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_mat_of_point2f.html">MatOfPoint2f</a>&#160;</td>
          <td class="paramname"><em>nextPts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_mat_of_byte.html">MatOfByte</a>&#160;</td>
          <td class="paramname"><em>status</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_mat_of_float.html">MatOfFloat</a>&#160;</td>
          <td class="paramname"><em>err</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_size.html">Size</a>&#160;</td>
          <td class="paramname"><em>winSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxLevel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates an optical flow for a sparse feature set using the iterative Lucas-Kanade method with pyramids.</p>
<p>The function implements a sparse iterative version of the Lucas-Kanade optical flow in pyramids. See [Bouguet00]. The function is parallelized with the TBB library.</p>
<p>Note:</p>
<ul>
<li>
An example using the Lucas-Kanade optical flow algorithm can be found at opencv_source_code/samples/cpp/lkdemo.cpp </li>
<li>
(Python) An example using the Lucas-Kanade optical flow algorithm can be found at opencv_source_code/samples/python2/lk_track.py </li>
<li>
(Python) An example using the Lucas-Kanade tracker for homography matching can be found at opencv_source_code/samples/python2/lk_homography.py </li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prevImg</td><td>first 8-bit input image or pyramid constructed by "buildOpticalFlowPyramid". </td></tr>
    <tr><td class="paramname">nextImg</td><td>second input image or pyramid of the same size and the same type as <code>prevImg</code>. </td></tr>
    <tr><td class="paramname">prevPts</td><td>vector of 2D points for which the flow needs to be found; point coordinates must be single-precision floating-point numbers. </td></tr>
    <tr><td class="paramname">nextPts</td><td>output vector of 2D points (with single-precision floating-point coordinates) containing the calculated new positions of input features in the second image; when <code>OPTFLOW_USE_INITIAL_FLOW</code> flag is passed, the vector must have the same size as in the input. </td></tr>
    <tr><td class="paramname">status</td><td>output status vector (of unsigned chars); each element of the vector is set to 1 if the flow for the corresponding features has been found, otherwise, it is set to 0. </td></tr>
    <tr><td class="paramname">err</td><td>output vector of errors; each element of the vector is set to an error for the corresponding feature, type of the error measure can be set in <code>flags</code> parameter; if the flow wasn't found then the error is not defined (use the <code>status</code> parameter to find such cases). </td></tr>
    <tr><td class="paramname">winSize</td><td>size of the search window at each pyramid level. </td></tr>
    <tr><td class="paramname">maxLevel</td><td>0-based maximal pyramid level number; if set to 0, pyramids are not used (single level), if set to 1, two levels are used, and so on; if pyramids are passed to input then algorithm will use as many levels as pyramids have but no more than <code>maxLevel</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="http://docs.opencv.org/modules/video/doc/motion_analysis_and_object_tracking.html#calcopticalflowpyrlk">org.opencv.video.Video.calcOpticalFlowPyrLK</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ad3b67253e8d617cdfbfa3a11130fccd6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.Video.calcOpticalFlowPyrLK </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>prevImg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>nextImg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_mat_of_point2f.html">MatOfPoint2f</a>&#160;</td>
          <td class="paramname"><em>prevPts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_mat_of_point2f.html">MatOfPoint2f</a>&#160;</td>
          <td class="paramname"><em>nextPts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_mat_of_byte.html">MatOfByte</a>&#160;</td>
          <td class="paramname"><em>status</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_mat_of_float.html">MatOfFloat</a>&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates an optical flow for a sparse feature set using the iterative Lucas-Kanade method with pyramids.</p>
<p>The function implements a sparse iterative version of the Lucas-Kanade optical flow in pyramids. See [Bouguet00]. The function is parallelized with the TBB library.</p>
<p>Note:</p>
<ul>
<li>
An example using the Lucas-Kanade optical flow algorithm can be found at opencv_source_code/samples/cpp/lkdemo.cpp </li>
<li>
(Python) An example using the Lucas-Kanade optical flow algorithm can be found at opencv_source_code/samples/python2/lk_track.py </li>
<li>
(Python) An example using the Lucas-Kanade tracker for homography matching can be found at opencv_source_code/samples/python2/lk_homography.py </li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prevImg</td><td>first 8-bit input image or pyramid constructed by "buildOpticalFlowPyramid". </td></tr>
    <tr><td class="paramname">nextImg</td><td>second input image or pyramid of the same size and the same type as <code>prevImg</code>. </td></tr>
    <tr><td class="paramname">prevPts</td><td>vector of 2D points for which the flow needs to be found; point coordinates must be single-precision floating-point numbers. </td></tr>
    <tr><td class="paramname">nextPts</td><td>output vector of 2D points (with single-precision floating-point coordinates) containing the calculated new positions of input features in the second image; when <code>OPTFLOW_USE_INITIAL_FLOW</code> flag is passed, the vector must have the same size as in the input. </td></tr>
    <tr><td class="paramname">status</td><td>output status vector (of unsigned chars); each element of the vector is set to 1 if the flow for the corresponding features has been found, otherwise, it is set to 0. </td></tr>
    <tr><td class="paramname">err</td><td>output vector of errors; each element of the vector is set to an error for the corresponding feature, type of the error measure can be set in <code>flags</code> parameter; if the flow wasn't found then the error is not defined (use the <code>status</code> parameter to find such cases).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="http://docs.opencv.org/modules/video/doc/motion_analysis_and_object_tracking.html#calcopticalflowpyrlk">org.opencv.video.Video.calcOpticalFlowPyrLK</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ac33aa50f9ddb2ffdafb37bfaa5f6403d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.Video.calcOpticalFlowSF </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>flow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>layers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>averaging_block_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_flow</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculate an optical flow using "SimpleFlow" algorithm.</p>
<p>See [Tao2012]. And site of project - <a href="http://graphics.berkeley.edu/papers/Tao-SAN-2012-05/">http://graphics.berkeley.edu/papers/Tao-SAN-2012-05/</a>.</p>
<p>Note:</p>
<ul>
<li>
An example using the simpleFlow algorithm can be found at opencv_source_code/samples/cpp/simpleflow_demo.cpp </li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>a from </td></tr>
    <tr><td class="paramname">to</td><td>a to </td></tr>
    <tr><td class="paramname">flow</td><td>a flow </td></tr>
    <tr><td class="paramname">layers</td><td>Number of layers </td></tr>
    <tr><td class="paramname">averaging_block_size</td><td><a class="el" href="class_open_c_v_for_unity_1_1_size.html">Size</a> of block through which we sum up when calculate cost function for pixel </td></tr>
    <tr><td class="paramname">max_flow</td><td>maximal flow that we search at each level</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="http://docs.opencv.org/modules/video/doc/motion_analysis_and_object_tracking.html#calcopticalflowsf">org.opencv.video.Video.calcOpticalFlowSF</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a3cbbdb473e74e22c0b173db981838e72"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.Video.calcOpticalFlowSF </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>flow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>layers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>averaging_block_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_flow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sigma_dist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sigma_color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>postprocess_window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sigma_dist_fix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sigma_color_fix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>occ_thr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>upscale_averaging_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>upscale_sigma_dist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>upscale_sigma_color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>speed_up_thr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculate an optical flow using "SimpleFlow" algorithm.</p>
<p>See [Tao2012]. And site of project - <a href="http://graphics.berkeley.edu/papers/Tao-SAN-2012-05/">http://graphics.berkeley.edu/papers/Tao-SAN-2012-05/</a>.</p>
<p>Note:</p>
<ul>
<li>
An example using the simpleFlow algorithm can be found at opencv_source_code/samples/cpp/simpleflow_demo.cpp </li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>a from </td></tr>
    <tr><td class="paramname">to</td><td>a to </td></tr>
    <tr><td class="paramname">flow</td><td>a flow </td></tr>
    <tr><td class="paramname">layers</td><td>Number of layers </td></tr>
    <tr><td class="paramname">averaging_block_size</td><td><a class="el" href="class_open_c_v_for_unity_1_1_size.html">Size</a> of block through which we sum up when calculate cost function for pixel </td></tr>
    <tr><td class="paramname">max_flow</td><td>maximal flow that we search at each level </td></tr>
    <tr><td class="paramname">sigma_dist</td><td>vector smooth spatial sigma parameter </td></tr>
    <tr><td class="paramname">sigma_color</td><td>vector smooth color sigma parameter </td></tr>
    <tr><td class="paramname">postprocess_window</td><td>window size for postprocess cross bilateral filter </td></tr>
    <tr><td class="paramname">sigma_dist_fix</td><td>spatial sigma for postprocess cross bilateralf filter </td></tr>
    <tr><td class="paramname">sigma_color_fix</td><td>color sigma for postprocess cross bilateral filter </td></tr>
    <tr><td class="paramname">occ_thr</td><td>threshold for detecting occlusions </td></tr>
    <tr><td class="paramname">upscale_averaging_radius</td><td>a upscale_averaging_radius </td></tr>
    <tr><td class="paramname">upscale_sigma_dist</td><td>spatial sigma for bilateral upscale operation </td></tr>
    <tr><td class="paramname">upscale_sigma_color</td><td>color sigma for bilateral upscale operation </td></tr>
    <tr><td class="paramname">speed_up_thr</td><td>threshold to detect point with irregular flow - where flow should be recalculated after upscale</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="http://docs.opencv.org/modules/video/doc/motion_analysis_and_object_tracking.html#calcopticalflowsf">org.opencv.video.Video.calcOpticalFlowSF</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ada39d82368b80249ece706a52ed46b87"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_open_c_v_for_unity_1_1_rotated_rect.html">RotatedRect</a> OpenCVForUnity.Video.CamShift </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>probImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_rect.html">Rect</a>&#160;</td>
          <td class="paramname"><em>window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_term_criteria.html">TermCriteria</a>&#160;</td>
          <td class="paramname"><em>criteria</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Finds an object center, size, and orientation.</p>
<p>The function implements the CAMSHIFT object tracking algorithm [Bradski98]. First, it finds an object center using "meanShift" and then adjusts the window size and finds the optimal rotation. The function returns the rotated rectangle structure that includes the object position, size, and orientation. The next position of the search window can be obtained with <code><a class="el" href="class_open_c_v_for_unity_1_1_rotated_rect.html#af3c3b3dd97043fb1f0b0628b3c19318d">RotatedRect.boundingRect()</a></code>.</p>
<p>See the OpenCV sample <code>camshiftdemo.c</code> that tracks colored objects.</p>
<p>Note:</p>
<ul>
<li>
(Python) A sample explaining the camshift tracking algorithm can be found at opencv_source_code/samples/python2/camshift.py </li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">probImage</td><td>Back projection of the object histogram. See "calcBackProject". </td></tr>
    <tr><td class="paramname">window</td><td>Initial search window. </td></tr>
    <tr><td class="paramname">criteria</td><td>Stop criteria for the underlying "meanShift".</td></tr>
  </table>
  </dd>
</dl>
<p>:returns: (in old interfaces) Number of iterations CAMSHIFT took to converge</p>
<dl class="section see"><dt>See also</dt><dd><a href="http://docs.opencv.org/modules/video/doc/motion_analysis_and_object_tracking.html#camshift">org.opencv.video.Video.CamShift</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a2daabeecdb0a1c965b9d64cdcae4fdbd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_open_c_v_for_unity_1_1_mat.html">Mat</a> OpenCVForUnity.Video.estimateRigidTransform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fullAffine</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Computes an optimal affine transformation between two 2D point sets.</p>
<p>The function finds an optimal affine transform *[A|b]* (a <code>2 x 3</code> floating-point matrix) that approximates best the affine transformation between:</p>
<ul>
<li>
Two point sets </li>
<li>
Two raster images. In this case, the function first finds some features in the <code>src</code> image and finds the corresponding features in <code>dst</code> image. After that, the problem is reduced to the first case. </li>
</ul>
<p>In case of point sets, the problem is formulated as follows: you need to find a 2x2 matrix <em>A</em> and 2x1 vector <em>b</em> so that:</p>
<p><em>[A^*|b^*] = arg min _([A|b]) sum _i|dst[i] - A (src[i])^T - b| ^2</em></p>
<p>where <code>src[i]</code> and <code>dst[i]</code> are the i-th points in <code>src</code> and <code>dst</code>, respectively</p>
<p><em>[A|b]</em> can be either arbitrary (when <code>fullAffine=true</code>) or have a form of</p>
<p><em>a_11 a_12 b_1 -a_12 a_11 b_2 </em></p>
<p>when <code>fullAffine=false</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>First input 2D point set stored in <code>std.vector</code> or <code><a class="el" href="class_open_c_v_for_unity_1_1_mat.html">Mat</a></code>, or an image stored in <code><a class="el" href="class_open_c_v_for_unity_1_1_mat.html">Mat</a></code>. </td></tr>
    <tr><td class="paramname">dst</td><td>Second input 2D point set of the same size and the same type as <code>A</code>, or another image. </td></tr>
    <tr><td class="paramname">fullAffine</td><td>If true, the function finds an optimal affine transformation with no additional restrictions (6 degrees of freedom). Otherwise, the class of transformations to choose from is limited to combinations of translation, rotation, and uniform scaling (5 degrees of freedom).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="http://docs.opencv.org/modules/video/doc/motion_analysis_and_object_tracking.html#estimaterigidtransform">org.opencv.video.Video.estimateRigidTransform</a> </dd>
<dd>
org.opencv.calib3d.Calib3d::findHomography </dd>
<dd>
org.opencv.imgproc.Imgproc::getAffineTransform </dd>
<dd>
org.opencv.imgproc.Imgproc::getPerspectiveTransform </dd></dl>

</div>
</div>
<a class="anchor" id="adc1fbfaaec0372c681161761a5ea9de2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int OpenCVForUnity.Video.meanShift </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>probImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_rect.html">Rect</a>&#160;</td>
          <td class="paramname"><em>window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_term_criteria.html">TermCriteria</a>&#160;</td>
          <td class="paramname"><em>criteria</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Finds an object on a back projection image.</p>
<p>The function implements the iterative object search algorithm. It takes the input back projection of an object and the initial position. The mass center in <code>window</code> of the back projection image is computed and the search window center shifts to the mass center. The procedure is repeated until the specified number of iterations <code>criteria.maxCount</code> is done or until the window center shifts by less than <code>criteria.epsilon</code>. The algorithm is used inside "CamShift" and, unlike "CamShift", the search window size or orientation do not change during the search. You can simply pass the output of "calcBackProject" to this function. But better results can be obtained if you pre-filter the back projection and remove the noise. For example, you can do this by retrieving connected components with "findContours", throwing away contours with small area ("contourArea"), and rendering the remaining contours with "drawContours".</p>
<p>Note:</p>
<ul>
<li>
A mean-shift tracking sample can be found at opencv_source_code/samples/cpp/camshiftdemo.cpp </li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">probImage</td><td>Back projection of the object histogram. See "calcBackProject" for details. </td></tr>
    <tr><td class="paramname">window</td><td>Initial search window. </td></tr>
    <tr><td class="paramname">criteria</td><td>Stop criteria for the iterative search algorithm.</td></tr>
  </table>
  </dd>
</dl>
<p>:returns: Number of iterations CAMSHIFT took to converge.</p>
<dl class="section see"><dt>See also</dt><dd><a href="http://docs.opencv.org/modules/video/doc/motion_analysis_and_object_tracking.html#meanshift">org.opencv.video.Video.meanShift</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a5c47ec68ea0a534ac593795f2d04f33e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.Video.segmentMotion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>mhi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>segmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_mat_of_rect.html">MatOfRect</a>&#160;</td>
          <td class="paramname"><em>boundingRects</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>timestamp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>segThresh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Splits a motion history image into a few parts corresponding to separate independent motions (for example, left hand, right hand).</p>
<p>The function finds all of the motion segments and marks them in <code>segmask</code> with individual values (1,2,...). It also computes a vector with ROIs of motion connected components. After that the motion direction for every component can be calculated with "calcGlobalOrientation" using the extracted mask of the particular component.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mhi</td><td>Motion history image. </td></tr>
    <tr><td class="paramname">segmask</td><td>Image where the found mask should be stored, single-channel, 32-bit floating-point. </td></tr>
    <tr><td class="paramname">boundingRects</td><td>Vector containing ROIs of motion connected components. </td></tr>
    <tr><td class="paramname">timestamp</td><td>Current time in milliseconds or other units. </td></tr>
    <tr><td class="paramname">segThresh</td><td>Segmentation threshold that is recommended to be equal to the interval between motion history "steps" or greater.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="http://docs.opencv.org/modules/video/doc/motion_analysis_and_object_tracking.html#segmentmotion">org.opencv.video.Video.segmentMotion</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a067f4aa0a58ad4e8514610dc102faf03"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.Video.updateMotionHistory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>silhouette</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>mhi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>timestamp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>duration</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Updates the motion history image by a moving silhouette.</p>
<p>The function updates the motion history image as follows:</p>
<p><em>mhi(x,y)= timestamp if silhouette(x,y) != 0; 0 if silhouette(x,y) = 0 and mhi &amp;lt(timestamp - duration); mhi(x,y) otherwise</em></p>
<p>That is, MHI pixels where the motion occurs are set to the current <code>timestamp</code>, while the pixels where the motion happened last time a long time ago are cleared.</p>
<p>The function, together with "calcMotionGradient" and "calcGlobalOrientation", implements a motion templates technique described in [Davis97] and [Bradski00]. See also the OpenCV sample <code>motempl.c</code> that demonstrates the use of all the motion template functions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">silhouette</td><td>Silhouette mask that has non-zero pixels where the motion occurs. </td></tr>
    <tr><td class="paramname">mhi</td><td>Motion history image that is updated by the function (single-channel, 32-bit floating-point). </td></tr>
    <tr><td class="paramname">timestamp</td><td>Current time in milliseconds or other units. </td></tr>
    <tr><td class="paramname">duration</td><td>Maximal duration of the motion track in the same units as <code>timestamp</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="http://docs.opencv.org/modules/video/doc/motion_analysis_and_object_tracking.html#updatemotionhistory">org.opencv.video.Video.updateMotionHistory</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="aedde09a0a8a8e53ea12e220addf457e8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.Video.OPTFLOW_FARNEBACK_GAUSSIAN = 256</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab8a128cacf80c603f4e4ec606bdb7c96"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.Video.OPTFLOW_LK_GET_MIN_EIGENVALS = CV_LKFLOW_GET_MIN_EIGENVALS</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a889951e2e5caf051015e8b46247ea73d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.Video.OPTFLOW_USE_INITIAL_FLOW = CV_LKFLOW_INITIAL_GUESSES</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>OpenCVForUnity/org/opencv/video/<a class="el" href="_video_8cs.html">Video.cs</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Oct 21 2015 23:57:07 for OpenCV for Unity by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
